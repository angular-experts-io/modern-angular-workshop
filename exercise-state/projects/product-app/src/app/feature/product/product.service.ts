import { Injectable } from '@angular/core';

// TODO 4: remove the providedIn property in the service pre-generated by Angular Schematics
// and make sure to add it to the providers: [] array in the lazy feature routes file
@Injectable({
  providedIn: 'root',
})
export class ProductService {
  // TODO 9: inject ProductApiService into the service (private, use # prefix)

  // TODO 5: (info) the general idea of service based state management is to have a single source of truth
  // and centralized location to manage the state of the feature (at this point, the product feature)
  // this allows us to access the same state from multiple components from unrelated parts of the application
  // (eg not direct parent child, because the component is displayed through a router-outlet, modal, dialog, ...)
  // previously implemented manual state refresh would often be in practice done with some ad-hoc
  // service based state synchronization logic, over time this logic grows and causes lot's of bugs

  // TODO 6: good thing is that with properly separated component based state management
  // we can create a new store and migrate state logic on a per component basis
  // in this exercise we're going to start with the product list component
  // the product list components contain following signal based state properties:
  //
  // query
  // loading
  // loadingSkeleton
  // error
  // products
  //
  // queryParamsFromUrl
  // outletActivated
  // showFilter
  //
  // the second group are component specific state properties, we're going to leave them as is
  // but the rest can be extracted into this service!

  // private state

  // TODO 7: let's define query, loading, loadingSkeleton, error and products
  // as private signals using # Javascript based privacy which solves also prefixing problem
  // for products, just define it as a signal<Product[]>([]) instead of logic how to retrieve them

  // public state
  // TODO 8: lets expose all of our signals as public signals (without #prefix)
  // which will be initialized to the corresponding private signals with .asReadonly() call

  // effects
  constructor() {
    // TODO 11: let's use our freshly defined "loadByQuery" method to reload products
    // whenever the query changes using the signals effect method
    // signals effects runs once initially which takes care of our initial load
  }

  // state change methods
  // TODO 16: let's define a method to update the #query called "updateQuery"
  // the explicit methods represent only way how to update the state of the service
  // this is preferable to exposing the signals directly, because it allows us to
  // add additional logic (eg. validation, side effects, ...) to the state change

  // async methods
  // TODO 10: let's define a method to load products by query called "loadByQuery"
  // the original component based implementation used RxJs stream and switchMap
  // to make sure we only get the latest response and prevent race conditions
  // here, a standard method call would not be enough, because it could be called multiple times
  // which is not good (racing condition, multiple requests)

  // but we can fix it by using a tiny helper from @ngrx/signals package called rxMethod
  // which is factory which abstracts away "streamification" of the method call
  // because of this, we're going to initialize "loadByQuery" to be a call
  // to rxMethod with a generic type of string, inside the rxMethod
  // we're going to pass an arrow function which has a query (RxJs Observable) as an argument

  // inside the arrow function we're going to provide logic similar to the one which
  // was used in the product list to define the products signal
  // then the resulting stream will start by the streamified "query" and in pipe...
  // we can literally copy the logic and replace the <some-signal>.set calls with #<some-signal>.set calls
  // and remove the "mergeWith" operator, because we're not going to use it in the service
  // THE BIGGEST DIFFERENCE is that we have to set received products to the products signal manually
  // last "tap" operator receives products as an argument, and we're going to set them to the #products signal

  // TODO 20: let's add a remove method which is going to call the productApiService.remove method
  // this method doesn't ned to use rxMethod, because it's not going to be called multiple times
  // as we should be disabling the UI button when the request is in progress (or perform optimistic update)
  // the method should accept product id as an argument and perform remove API call
  // the method will need to explicitly subscribe to trigger the request
  // the method should call the "loadByQuery" with current value of the query signal on success
  // the method should set loading (but not unset, why?) signal and handle errors
  // there are multiple ways to solve this, choose the one you feel comfortable with
}
